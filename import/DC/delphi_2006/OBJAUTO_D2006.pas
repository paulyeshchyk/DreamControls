{*******************************************************}
{                                                       }
{ Import  unit generated by UNITIMPORTER program         }
{                                                       }
{*******************************************************}

{} unit OBJAUTO_D2006;
interface
{$I dc.inc}
{$D-,L-,Y-}
{$HINTS OFF}
{$WARNINGS OFF}
uses
  activex,
  classes,
  dcscript,
  dcsystem,
  dcdreamlib,
  TypInfo,
  ObjAuto;
function ConvertTMethodToVariant(var R : TMethod) : OleVariant;
function ConvertVariantToTMethod(const V : OleVariant) : TMethod;
function ConvertTMethodInfoHeaderToVariant(var R : TMethodInfoHeader) : OleVariant;
function ConvertVariantToTMethodInfoHeader(const V : OleVariant) : TMethodInfoHeader;
function ConvertTParamInfoToVariant(var R : TParamInfo) : OleVariant;
function ConvertVariantToTParamInfo(const V : OleVariant) : TParamInfo;
function ConvertTReturnInfoToVariant(var R : TReturnInfo) : OleVariant;
function ConvertVariantToTReturnInfo(const V : OleVariant) : TReturnInfo;
implementation
{$IFDEF D3}
{$ELSE}
uses ole2;
type
  OleVariant = Variant;
{$ENDIF}
type __TMethodInfoHeader__Wrapper = class(TDCRecordWrapper)
private
fR : TMethodInfoHeader;
public
function GetRecordPtr : pointer; override;
published
procedure setLen(const val : Word);
function getLen : Word;
property Len : Word read getLen write setLen;
end;
type __TParamInfo__Wrapper = class(TDCRecordWrapper)
private
fR : TParamInfo;
public
function GetRecordPtr : pointer; override;
published
procedure setAccess(const val : Word);
function getAccess : Word;
property Access : Word read getAccess write setAccess;
end;
type __TReturnInfo__Wrapper = class(TDCRecordWrapper)
private
fR : TReturnInfo;
public
function GetRecordPtr : pointer; override;
published
procedure setVersion(const val : Byte);
function getVersion : Byte;
property Version : Byte read getVersion write setVersion;
procedure setCallingConvention(const val : TCallingConvention);
function getCallingConvention : TCallingConvention;
property CallingConvention : TCallingConvention read getCallingConvention write setCallingConvention;
procedure setParamSize(const val : Word);
function getParamSize : Word;
property ParamSize : Word read getParamSize write setParamSize;
end;
type __TMethod__Wrapper = class(TDCRecordWrapper)
private
fR : TMethod;
public
function GetRecordPtr : pointer; override;
published
end;
type
{_T0 = function (p0 : TObject;
p1 : PMethodInfoHeader;
const p2 : Array of Integer;
const p3 : Array of Variant): Variant of object;}

{_T1 = function (p0 : TObject;
const p1 : ShortString): PMethodInfoHeader of object;}

_T3 = procedure (const p0 : IDispatch) of object;

function __TMethodInfoHeader__Wrapper.GetRecordPtr : pointer;
begin
result := @fR;
end;
procedure __TMethodInfoHeader__Wrapper.setLen(const val : Word);
begin
TMethodInfoHeader(GetRecordPtr^).Len := val;
end;
function __TMethodInfoHeader__Wrapper.getLen : Word;
begin
result := TMethodInfoHeader(GetRecordPtr^).Len;
end;
function __TParamInfo__Wrapper.GetRecordPtr : pointer;
begin
result := @fR;
end;
procedure __TParamInfo__Wrapper.setAccess(const val : Word);
begin
TParamInfo(GetRecordPtr^).Access := val;
end;
function __TParamInfo__Wrapper.getAccess : Word;
begin
result := TParamInfo(GetRecordPtr^).Access;
end;
function __TReturnInfo__Wrapper.GetRecordPtr : pointer;
begin
result := @fR;
end;
procedure __TReturnInfo__Wrapper.setVersion(const val : Byte);
begin
TReturnInfo(GetRecordPtr^).Version := val;
end;
function __TReturnInfo__Wrapper.getVersion : Byte;
begin
result := TReturnInfo(GetRecordPtr^).Version;
end;
procedure __TReturnInfo__Wrapper.setCallingConvention(const val : TCallingConvention);
begin
TReturnInfo(GetRecordPtr^).CallingConvention := val;
end;
function __TReturnInfo__Wrapper.getCallingConvention : TCallingConvention;
begin
result := TReturnInfo(GetRecordPtr^).CallingConvention;
end;
procedure __TReturnInfo__Wrapper.setParamSize(const val : Word);
begin
TReturnInfo(GetRecordPtr^).ParamSize := val;
end;
function __TReturnInfo__Wrapper.getParamSize : Word;
begin
result := TReturnInfo(GetRecordPtr^).ParamSize;
end;
function _TMethodInfoHeader_ : IDispatch;
begin
  result := __TMethodInfoHeader__Wrapper.Create;
end;
function _TParamInfo_ : IDispatch;
begin
  result := __TParamInfo__Wrapper.Create;
end;
function _TReturnInfo_ : IDispatch;
begin
  result := __TReturnInfo__Wrapper.Create;
end;
function __TMethod__Wrapper.GetRecordPtr : pointer;
begin
result := @fR;
end;
procedure ____ReleaseMethodPointer__Wrapper(const p0 : IDispatch);
var
__p0 : ^TMethod;
__i0 : IDispatch;
begin
if p0 = nil then exit;
__p0 := (p0 as IDCRecordWrapper).GetRecordPtr;
ReleaseMethodPointer(__p0^);
end;


type __TMethod__Wrapper__ = class(__TMethod__Wrapper)
private
fRPtr : pointer;
function GetRecordPtr : pointer; override;
end;
function __TMethod__Wrapper__.GetRecordPtr : pointer;
begin
result := fRPtr;
end;
function ConvertTMethodToVariant(var R : TMethod) : OleVariant;
var
__rw : __TMethod__Wrapper__;
begin
__rw := __TMethod__Wrapper__.Create;
__rw.fRPtr := @R;
result := IDispatch(__rw);
end;
function ConvertVariantToTMethod(const V : OleVariant) : TMethod;
var
_idisp : IDispatch;
begin
_idisp := VarToInterface(v);
if _idisp = nil then exit;
result := TMethod((_idisp as IDCRecordWrapper).GetRecordPtr^);
end;

type __TMethodInfoHeader__Wrapper__ = class(__TMethodInfoHeader__Wrapper)
private
fRPtr : pointer;
function GetRecordPtr : pointer; override;
end;
function __TMethodInfoHeader__Wrapper__.GetRecordPtr : pointer;
begin
result := fRPtr;
end;
function ConvertTMethodInfoHeaderToVariant(var R : TMethodInfoHeader) : OleVariant;
var
__rw : __TMethodInfoHeader__Wrapper__;
begin
__rw := __TMethodInfoHeader__Wrapper__.Create;
__rw.fRPtr := @R;
result := IDispatch(__rw);
end;
function ConvertVariantToTMethodInfoHeader(const V : OleVariant) : TMethodInfoHeader;
var
_idisp : IDispatch;
begin
_idisp := VarToInterface(v);
if _idisp = nil then exit;
result := TMethodInfoHeader((_idisp as IDCRecordWrapper).GetRecordPtr^);
end;

type __TParamInfo__Wrapper__ = class(__TParamInfo__Wrapper)
private
fRPtr : pointer;
function GetRecordPtr : pointer; override;
end;
function __TParamInfo__Wrapper__.GetRecordPtr : pointer;
begin
result := fRPtr;
end;
function ConvertTParamInfoToVariant(var R : TParamInfo) : OleVariant;
var
__rw : __TParamInfo__Wrapper__;
begin
__rw := __TParamInfo__Wrapper__.Create;
__rw.fRPtr := @R;
result := IDispatch(__rw);
end;
function ConvertVariantToTParamInfo(const V : OleVariant) : TParamInfo;
var
_idisp : IDispatch;
begin
_idisp := VarToInterface(v);
if _idisp = nil then exit;
result := TParamInfo((_idisp as IDCRecordWrapper).GetRecordPtr^);
end;

type __TReturnInfo__Wrapper__ = class(__TReturnInfo__Wrapper)
private
fRPtr : pointer;
function GetRecordPtr : pointer; override;
end;
function __TReturnInfo__Wrapper__.GetRecordPtr : pointer;
begin
result := fRPtr;
end;
function ConvertTReturnInfoToVariant(var R : TReturnInfo) : OleVariant;
var
__rw : __TReturnInfo__Wrapper__;
begin
__rw := __TReturnInfo__Wrapper__.Create;
__rw.fRPtr := @R;
result := IDispatch(__rw);
end;
function ConvertVariantToTReturnInfo(const V : OleVariant) : TReturnInfo;
var
_idisp : IDispatch;
begin
_idisp := VarToInterface(v);
if _idisp = nil then exit;
result := TReturnInfo((_idisp as IDCRecordWrapper).GetRecordPtr^);
end;
procedure __RegisterProps;
begin
end;

const __ConstNames0 : array[0..15] of string = (
'paEAX'
,'paEDX'
,'paECX'
,'paStack'
,'ccRegister'
,'ccCdecl'
,'ccPascal'
,'ccStdCall'
,'ccSafeCall'
,'pfVar'
,'pfConst'
,'pfArray'
,'pfAddress'
,'pfReference'
,'pfOut'
,'pfResult'
);
var __RegisteredConstsList0 : TList;
procedure __RegisterConsts0;
begin
__RegisteredConstsList0 := TList.Create;
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[0] ,paEAX));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[1] ,paEDX));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[2] ,paECX));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[3] ,paStack));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[4] ,ccRegister));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[5] ,ccCdecl));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[6] ,ccPascal));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[7] ,ccStdCall));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[8] ,ccSafeCall));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[9] ,pfVar));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[10] ,pfConst));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[11] ,pfArray));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[12] ,pfAddress));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[13] ,pfReference));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[14] ,pfOut));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[15] ,pfResult));
end;

procedure __UnregisterConsts0;
var i : integer;
begin
__RegisteredConstsList0.Free
end;

procedure __RegisterClasses;
begin
end;

procedure __UnRegisterClasses;
begin
end;

var __RegisteredMethods : TList;
const MethodNames : array[0..3] of string = (
'TMethodInfoHeader'
,'TParamInfo'
,'TReturnInfo'
,'ReleaseMethodPointer'
);

procedure __UnregisterProcs;
var i : integer;
begin
__RegisteredMethods.Free;
end;

procedure _mreg_0;
begin
__RegisteredMethods.Add(RegisterRWProc(MethodNames[0],Addr(_TMethodInfoHeader_)));
__RegisteredMethods.Add(RegisterRWProc(MethodNames[1],Addr(_TParamInfo_)));
__RegisteredMethods.Add(RegisterRWProc(MethodNames[2],Addr(_TReturnInfo_)));
RegisterProc(nil,MethodNames[3],mtProc,TypeInfo(_T3),[
TypeInfo(IDispatch)],Addr(____ReleaseMethodPointer__Wrapper),cRegister);

end;
initialization
__RegisteredMethods := TList.Create;
_mreg_0;
{RegisterProc(nil,'ObjectInvoke',mtProc,TypeInfo(_T0),[
TypeInfo(TObject),
TypeInfoPointer,
ArrayInfo(TypeInfo(Integer)),
ArrayInfo(TypeInfo(Variant)),TypeInfo(Variant)],Addr(ObjectInvoke),cRegister)}

{RegisterProc(nil,'GetMethodInfo',mtProc,TypeInfo(_T1),[
TypeInfo(TObject),
TypeInfo(ShortString),TypeInfoPointer],Addr(GetMethodInfo),cRegister)}

__RegisterClasses;
__RegisterConsts0;
__RegisterProps;

finalization
__UnRegisterClasses;
__UnregisterConsts0;
__UnregisterProcs;
end.
