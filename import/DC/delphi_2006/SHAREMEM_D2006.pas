{*******************************************************}
{                                                       }
{ Import  unit generated by UNITIMPORTER program         }
{                                                       }
{*******************************************************}

{} unit SHAREMEM_D2006;
interface
{$I dc.inc}
{$D-,L-,Y-}
{$HINTS OFF}
{$WARNINGS OFF}
uses
  activex,
  classes,
  dcscript,
  dcsystem,
  dcdreamlib,
  ShareMem;
function ConvertTHeapStatusToVariant(var R : THeapStatus) : OleVariant;
function ConvertVariantToTHeapStatus(const V : OleVariant) : THeapStatus;
implementation
{$IFDEF D3}
{$ELSE}
uses ole2;
type
  OleVariant = Variant;
{$ENDIF}
type __THeapStatus__Wrapper = class(TDCRecordWrapper)
private
fR : THeapStatus;
public
function GetRecordPtr : pointer; override;
published
procedure setTotalAddrSpace(const val : Cardinal);
function getTotalAddrSpace : Cardinal;
property TotalAddrSpace : Cardinal read getTotalAddrSpace write setTotalAddrSpace;
procedure setTotalUncommitted(const val : Cardinal);
function getTotalUncommitted : Cardinal;
property TotalUncommitted : Cardinal read getTotalUncommitted write setTotalUncommitted;
procedure setTotalCommitted(const val : Cardinal);
function getTotalCommitted : Cardinal;
property TotalCommitted : Cardinal read getTotalCommitted write setTotalCommitted;
procedure setTotalAllocated(const val : Cardinal);
function getTotalAllocated : Cardinal;
property TotalAllocated : Cardinal read getTotalAllocated write setTotalAllocated;
procedure setTotalFree(const val : Cardinal);
function getTotalFree : Cardinal;
property TotalFree : Cardinal read getTotalFree write setTotalFree;
procedure setFreeSmall(const val : Cardinal);
function getFreeSmall : Cardinal;
property FreeSmall : Cardinal read getFreeSmall write setFreeSmall;
procedure setFreeBig(const val : Cardinal);
function getFreeBig : Cardinal;
property FreeBig : Cardinal read getFreeBig write setFreeBig;
procedure setUnused(const val : Cardinal);
function getUnused : Cardinal;
property Unused : Cardinal read getUnused write setUnused;
procedure setOverhead(const val : Cardinal);
function getOverhead : Cardinal;
property Overhead : Cardinal read getOverhead write setOverhead;
procedure setHeapErrorCode(const val : Cardinal);
function getHeapErrorCode : Cardinal;
property HeapErrorCode : Cardinal read getHeapErrorCode write setHeapErrorCode;
end;
type
_T0 = function (p0 : Integer): Pointer of object;

_T1 = function (p0 : Pointer): Integer of object;

_T2 = function (p0 : Pointer;
p1 : Integer): Pointer of object;

_T3 = function (p0 : Cardinal): Pointer of object;

_T4 = function (p0 : Pointer): Boolean of object;

_T5 = _T4;

_T6 = function : IDispatch of object;

_T7 = function : Integer of object;

_T8 = _T7;

_T9 = procedure  of object;

_T10 = _T9;

_T11 = _T9;

function __THeapStatus__Wrapper.GetRecordPtr : pointer;
begin
result := @fR;
end;
procedure __THeapStatus__Wrapper.setTotalAddrSpace(const val : Cardinal);
begin
THeapStatus(GetRecordPtr^).TotalAddrSpace := val;
end;
function __THeapStatus__Wrapper.getTotalAddrSpace : Cardinal;
begin
result := THeapStatus(GetRecordPtr^).TotalAddrSpace;
end;
procedure __THeapStatus__Wrapper.setTotalUncommitted(const val : Cardinal);
begin
THeapStatus(GetRecordPtr^).TotalUncommitted := val;
end;
function __THeapStatus__Wrapper.getTotalUncommitted : Cardinal;
begin
result := THeapStatus(GetRecordPtr^).TotalUncommitted;
end;
procedure __THeapStatus__Wrapper.setTotalCommitted(const val : Cardinal);
begin
THeapStatus(GetRecordPtr^).TotalCommitted := val;
end;
function __THeapStatus__Wrapper.getTotalCommitted : Cardinal;
begin
result := THeapStatus(GetRecordPtr^).TotalCommitted;
end;
procedure __THeapStatus__Wrapper.setTotalAllocated(const val : Cardinal);
begin
THeapStatus(GetRecordPtr^).TotalAllocated := val;
end;
function __THeapStatus__Wrapper.getTotalAllocated : Cardinal;
begin
result := THeapStatus(GetRecordPtr^).TotalAllocated;
end;
procedure __THeapStatus__Wrapper.setTotalFree(const val : Cardinal);
begin
THeapStatus(GetRecordPtr^).TotalFree := val;
end;
function __THeapStatus__Wrapper.getTotalFree : Cardinal;
begin
result := THeapStatus(GetRecordPtr^).TotalFree;
end;
procedure __THeapStatus__Wrapper.setFreeSmall(const val : Cardinal);
begin
THeapStatus(GetRecordPtr^).FreeSmall := val;
end;
function __THeapStatus__Wrapper.getFreeSmall : Cardinal;
begin
result := THeapStatus(GetRecordPtr^).FreeSmall;
end;
procedure __THeapStatus__Wrapper.setFreeBig(const val : Cardinal);
begin
THeapStatus(GetRecordPtr^).FreeBig := val;
end;
function __THeapStatus__Wrapper.getFreeBig : Cardinal;
begin
result := THeapStatus(GetRecordPtr^).FreeBig;
end;
procedure __THeapStatus__Wrapper.setUnused(const val : Cardinal);
begin
THeapStatus(GetRecordPtr^).Unused := val;
end;
function __THeapStatus__Wrapper.getUnused : Cardinal;
begin
result := THeapStatus(GetRecordPtr^).Unused;
end;
procedure __THeapStatus__Wrapper.setOverhead(const val : Cardinal);
begin
THeapStatus(GetRecordPtr^).Overhead := val;
end;
function __THeapStatus__Wrapper.getOverhead : Cardinal;
begin
result := THeapStatus(GetRecordPtr^).Overhead;
end;
procedure __THeapStatus__Wrapper.setHeapErrorCode(const val : Cardinal);
begin
THeapStatus(GetRecordPtr^).HeapErrorCode := val;
end;
function __THeapStatus__Wrapper.getHeapErrorCode : Cardinal;
begin
result := THeapStatus(GetRecordPtr^).HeapErrorCode;
end;
function ____GetHeapStatus__Wrapper: IDispatch;
var
__result : THeapStatus;
__wrapper : __THeapStatus__Wrapper;
begin
__result := GetHeapStatus;
__wrapper := __THeapStatus__Wrapper.Create;
__wrapper.fR := __result;
result := IDispatch(__wrapper);
end;


type __THeapStatus__Wrapper__ = class(__THeapStatus__Wrapper)
private
fRPtr : pointer;
function GetRecordPtr : pointer; override;
end;
function __THeapStatus__Wrapper__.GetRecordPtr : pointer;
begin
result := fRPtr;
end;
function ConvertTHeapStatusToVariant(var R : THeapStatus) : OleVariant;
var
__rw : __THeapStatus__Wrapper__;
begin
__rw := __THeapStatus__Wrapper__.Create;
__rw.fRPtr := @R;
result := IDispatch(__rw);
end;
function ConvertVariantToTHeapStatus(const V : OleVariant) : THeapStatus;
var
_idisp : IDispatch;
begin
_idisp := VarToInterface(v);
if _idisp = nil then exit;
result := THeapStatus((_idisp as IDCRecordWrapper).GetRecordPtr^);
end;
procedure __RegisterProps;
begin
end;

procedure __RegisterConsts0;
begin
end;

procedure __UnregisterConsts0;
begin
end;

procedure __RegisterClasses;
begin
end;

procedure __UnRegisterClasses;
begin
end;

var __RegisteredMethods : TList;
const MethodNames : array[0..11] of string = (
'SysGetMem'
,'SysFreeMem'
,'SysReallocMem'
,'SysAllocMem'
,'SysRegisterExpectedMemoryLeak'
,'SysUnregisterExpectedMemoryLeak'
,'GetHeapStatus'
,'GetAllocMemCount'
,'GetAllocMemSize'
,'DumpBlocks'
,'HeapAddRef'
,'HeapRelease'
);

procedure __UnregisterProcs;
var i : integer;
begin
__RegisteredMethods.Free;
end;

procedure _mreg_0;
begin
RegisterProc(nil,MethodNames[0],mtProc,TypeInfo(_T0),[
TypeInfo(Integer),TypeInfoPointer],Addr(SysGetMem),cRegister);

RegisterProc(nil,MethodNames[1],mtProc,TypeInfo(_T1),[
TypeInfoPointer,TypeInfo(Integer)],Addr(SysFreeMem),cRegister);

RegisterProc(nil,MethodNames[2],mtProc,TypeInfo(_T2),[
TypeInfoPointer,
TypeInfo(Integer),TypeInfoPointer],Addr(SysReallocMem),cRegister);

RegisterProc(nil,MethodNames[3],mtProc,TypeInfo(_T3),[
TypeInfo(Cardinal),TypeInfoPointer],Addr(SysAllocMem),cRegister);

RegisterProc(nil,MethodNames[4],mtProc,TypeInfo(_T4),[
TypeInfoPointer,TypeInfo(Boolean)],Addr(SysRegisterExpectedMemoryLeak),cRegister);

RegisterProc(nil,MethodNames[5],mtProc,TypeInfo(_T5),[
TypeInfoPointer,TypeInfo(Boolean)],Addr(SysUnregisterExpectedMemoryLeak),cRegister);

RegisterProc(nil,MethodNames[6],mtProc,TypeInfo(_T6),[TypeInfo(IDispatch)],Addr(____GetHeapStatus__Wrapper),cRegister);

RegisterProc(nil,MethodNames[7],mtProc,TypeInfo(_T7),[TypeInfo(Integer)],Addr(GetAllocMemCount),cRegister);

RegisterProc(nil,MethodNames[8],mtProc,TypeInfo(_T8),[TypeInfo(Integer)],Addr(GetAllocMemSize),cRegister);

RegisterProc(nil,MethodNames[9],mtProc,TypeInfo(_T9),NoParams,Addr(DumpBlocks),cRegister);

RegisterProc(nil,MethodNames[10],mtProc,TypeInfo(_T10),NoParams,Addr(HeapAddRef),cRegister);

RegisterProc(nil,MethodNames[11],mtProc,TypeInfo(_T11),NoParams,Addr(HeapRelease),cRegister);

end;
initialization
__RegisteredMethods := TList.Create;
_mreg_0;
__RegisterClasses;
__RegisterConsts0;
__RegisterProps;

finalization
__UnRegisterClasses;
__UnregisterConsts0;
__UnregisterProcs;
end.
