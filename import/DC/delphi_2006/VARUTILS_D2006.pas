{*******************************************************}
{                                                       }
{ Import  unit generated by UNITIMPORTER program         }
{                                                       }
{*******************************************************}

{} unit VARUTILS_D2006;
interface
{$I dc.inc}
{$D-,L-,Y-}
{$HINTS OFF}
{$WARNINGS OFF}
uses
  activex,
  classes,
  dcscript,
  dcsystem,
  dcdreamlib,
  SysUtils,
  Types,
  SysConst,
  VarUtils;
function ConvertTVarDataToVariant(var R : TVarData) : OleVariant;
function ConvertVariantToTVarData(const V : OleVariant) : TVarData;
function ConvertTVarTypeToElementInfoToVariant(var R : TVarTypeToElementInfo) : OleVariant;
function ConvertVariantToTVarTypeToElementInfo(const V : OleVariant) : TVarTypeToElementInfo;
implementation
{$IFDEF D3}
{$ELSE}
uses ole2;
type
  OleVariant = Variant;
{$ENDIF}
type __TVarTypeToElementInfo__Wrapper = class(TDCRecordWrapper)
private
fR : TVarTypeToElementInfo;
public
function GetRecordPtr : pointer; override;
published
procedure setValidBase(const val : Boolean);
function getValidBase : Boolean;
property ValidBase : Boolean read getValidBase write setValidBase;
procedure setValidElement(const val : Boolean);
function getValidElement : Boolean;
property ValidElement : Boolean read getValidElement write setValidElement;
procedure setSize(const val : Integer);
function getSize : Integer;
property Size : Integer read getSize write setSize;
procedure setFlags(const val : Word);
function getFlags : Word;
property Flags : Word read getFlags write setFlags;
end;
type __TVarData__Wrapper = class(TDCRecordWrapper)
private
fR : TVarData;
public
function GetRecordPtr : pointer; override;
published
procedure setVType(const val : TVarType);
function getVType : TVarType;
property VType : TVarType read getVType write setVType;
procedure setReserved1(const val : Word);
function getReserved1 : Word;
property Reserved1 : Word read getReserved1 write setReserved1;
procedure setReserved2(const val : Word);
function getReserved2 : Word;
property Reserved2 : Word read getReserved2 write setReserved2;
procedure setReserved3(const val : Word);
function getReserved3 : Word;
property Reserved3 : Word read getReserved3 write setReserved3;
procedure setVSmallInt(const val : SmallInt);
function getVSmallInt : SmallInt;
property VSmallInt : SmallInt read getVSmallInt write setVSmallInt;
procedure setVInteger(const val : Integer);
function getVInteger : Integer;
property VInteger : Integer read getVInteger write setVInteger;
procedure setVSingle(const val : Single);
function getVSingle : Single;
property VSingle : Single read getVSingle write setVSingle;
procedure setVDouble(const val : Double);
function getVDouble : Double;
property VDouble : Double read getVDouble write setVDouble;
procedure setVCurrency(const val : Currency);
function getVCurrency : Currency;
property VCurrency : Currency read getVCurrency write setVCurrency;
procedure setVBoolean(const val : WordBool);
function getVBoolean : WordBool;
property VBoolean : WordBool read getVBoolean write setVBoolean;
procedure setVShortInt(const val : Shortint);
function getVShortInt : Shortint;
property VShortInt : Shortint read getVShortInt write setVShortInt;
procedure setVByte(const val : Byte);
function getVByte : Byte;
property VByte : Byte read getVByte write setVByte;
procedure setVWord(const val : Word);
function getVWord : Word;
property VWord : Word read getVWord write setVWord;
procedure setVLongWord(const val : LongWord);
function getVLongWord : LongWord;
property VLongWord : LongWord read getVLongWord write setVLongWord;
end;
type
_T0 = function (const p0 : Exception): HRESULT of object;

_T1 = procedure (const p0 : IDispatch) of object;

_T2 = function (const p0 : IDispatch): HRESULT of object;

_T3 = function (const p0 : IDispatch;
const p1 : IDispatch): HRESULT of object;

_T4 = _T3;

_T5 = function (const p0 : IDispatch;
const p1 : IDispatch;
p2 : Word;
p3 : Word): HRESULT of object;

{_T6 = function (p0 : Integer;
p1 : Integer;
const p2 : TVarArrayBoundArray): PVarArray of object;}

{_T7 = function (p0 : Integer;
out p1 : PVarArray): HRESULT of object;}

{_T8 = function (p0 : PVarArray): HRESULT of object;}

{_T9 = function (p0 : PVarArray): HRESULT of object;}

{_T10 = function (p0 : PVarArray): HRESULT of object;}

{_T11 = function (p0 : PVarArray): HRESULT of object;}

{_T13 = function (p0 : PVarArray;
out p1 : PVarArray): HRESULT of object;}

{_T14 = function (p0 : PVarArray;
p1 : PVarArray): HRESULT of object;}

{_T15 = function (p0 : PVarArray;
p1 : Integer;
out p2 : Integer): HRESULT of object;}

{_T16 = function (p0 : PVarArray;
p1 : Integer;
out p2 : Integer): HRESULT of object;}

{_T17 = function (p0 : PVarArray): Integer of object;}

{_T18 = function (p0 : PVarArray;
out p1 : Pointer): HRESULT of object;}

{_T19 = function (p0 : PVarArray): HRESULT of object;}

{_T20 = function (p0 : PVarArray): HRESULT of object;}

{_T21 = function (p0 : PVarArray): HRESULT of object;}

{_T22 = function (p0 : PVarArray;
p1 : PVarArrayCoorArray;
p2 : Pointer): HRESULT of object;}

{_T23 = function (p0 : PVarArray;
p1 : PVarArrayCoorArray;
const p2 : Pointer): HRESULT of object;}

{_T24 = function (p0 : PVarArray;
p1 : PVarArrayCoorArray;
var p2 : Pointer): HRESULT of object;}

{_T25 = function (p0 : PVarArray): LongWord of object;}

_T26 = procedure (p0 : HRESULT) of object;

_T27 = _T26;

_T28 = procedure (p0 : HRESULT;
const p1 : string) of object;

function __TVarTypeToElementInfo__Wrapper.GetRecordPtr : pointer;
begin
result := @fR;
end;
procedure __TVarTypeToElementInfo__Wrapper.setValidBase(const val : Boolean);
begin
TVarTypeToElementInfo(GetRecordPtr^).ValidBase := val;
end;
function __TVarTypeToElementInfo__Wrapper.getValidBase : Boolean;
begin
result := TVarTypeToElementInfo(GetRecordPtr^).ValidBase;
end;
procedure __TVarTypeToElementInfo__Wrapper.setValidElement(const val : Boolean);
begin
TVarTypeToElementInfo(GetRecordPtr^).ValidElement := val;
end;
function __TVarTypeToElementInfo__Wrapper.getValidElement : Boolean;
begin
result := TVarTypeToElementInfo(GetRecordPtr^).ValidElement;
end;
procedure __TVarTypeToElementInfo__Wrapper.setSize(const val : Integer);
begin
TVarTypeToElementInfo(GetRecordPtr^).Size := val;
end;
function __TVarTypeToElementInfo__Wrapper.getSize : Integer;
begin
result := TVarTypeToElementInfo(GetRecordPtr^).Size;
end;
procedure __TVarTypeToElementInfo__Wrapper.setFlags(const val : Word);
begin
TVarTypeToElementInfo(GetRecordPtr^).Flags := val;
end;
function __TVarTypeToElementInfo__Wrapper.getFlags : Word;
begin
result := TVarTypeToElementInfo(GetRecordPtr^).Flags;
end;
function _TVarTypeToElementInfo_ : IDispatch;
begin
  result := __TVarTypeToElementInfo__Wrapper.Create;
end;
function __TVarData__Wrapper.GetRecordPtr : pointer;
begin
result := @fR;
end;
procedure __TVarData__Wrapper.setVType(const val : TVarType);
begin
TVarData(GetRecordPtr^).VType := val;
end;
function __TVarData__Wrapper.getVType : TVarType;
begin
result := TVarData(GetRecordPtr^).VType;
end;
procedure __TVarData__Wrapper.setReserved1(const val : Word);
begin
TVarData(GetRecordPtr^).Reserved1 := val;
end;
function __TVarData__Wrapper.getReserved1 : Word;
begin
result := TVarData(GetRecordPtr^).Reserved1;
end;
procedure __TVarData__Wrapper.setReserved2(const val : Word);
begin
TVarData(GetRecordPtr^).Reserved2 := val;
end;
function __TVarData__Wrapper.getReserved2 : Word;
begin
result := TVarData(GetRecordPtr^).Reserved2;
end;
procedure __TVarData__Wrapper.setReserved3(const val : Word);
begin
TVarData(GetRecordPtr^).Reserved3 := val;
end;
function __TVarData__Wrapper.getReserved3 : Word;
begin
result := TVarData(GetRecordPtr^).Reserved3;
end;
procedure __TVarData__Wrapper.setVSmallInt(const val : SmallInt);
begin
TVarData(GetRecordPtr^).VSmallInt := val;
end;
function __TVarData__Wrapper.getVSmallInt : SmallInt;
begin
result := TVarData(GetRecordPtr^).VSmallInt;
end;
procedure __TVarData__Wrapper.setVInteger(const val : Integer);
begin
TVarData(GetRecordPtr^).VInteger := val;
end;
function __TVarData__Wrapper.getVInteger : Integer;
begin
result := TVarData(GetRecordPtr^).VInteger;
end;
procedure __TVarData__Wrapper.setVSingle(const val : Single);
begin
TVarData(GetRecordPtr^).VSingle := val;
end;
function __TVarData__Wrapper.getVSingle : Single;
begin
result := TVarData(GetRecordPtr^).VSingle;
end;
procedure __TVarData__Wrapper.setVDouble(const val : Double);
begin
TVarData(GetRecordPtr^).VDouble := val;
end;
function __TVarData__Wrapper.getVDouble : Double;
begin
result := TVarData(GetRecordPtr^).VDouble;
end;
procedure __TVarData__Wrapper.setVCurrency(const val : Currency);
begin
TVarData(GetRecordPtr^).VCurrency := val;
end;
function __TVarData__Wrapper.getVCurrency : Currency;
begin
result := TVarData(GetRecordPtr^).VCurrency;
end;
procedure __TVarData__Wrapper.setVBoolean(const val : WordBool);
begin
TVarData(GetRecordPtr^).VBoolean := val;
end;
function __TVarData__Wrapper.getVBoolean : WordBool;
begin
result := TVarData(GetRecordPtr^).VBoolean;
end;
procedure __TVarData__Wrapper.setVShortInt(const val : Shortint);
begin
TVarData(GetRecordPtr^).VShortInt := val;
end;
function __TVarData__Wrapper.getVShortInt : Shortint;
begin
result := TVarData(GetRecordPtr^).VShortInt;
end;
procedure __TVarData__Wrapper.setVByte(const val : Byte);
begin
TVarData(GetRecordPtr^).VByte := val;
end;
function __TVarData__Wrapper.getVByte : Byte;
begin
result := TVarData(GetRecordPtr^).VByte;
end;
procedure __TVarData__Wrapper.setVWord(const val : Word);
begin
TVarData(GetRecordPtr^).VWord := val;
end;
function __TVarData__Wrapper.getVWord : Word;
begin
result := TVarData(GetRecordPtr^).VWord;
end;
procedure __TVarData__Wrapper.setVLongWord(const val : LongWord);
begin
TVarData(GetRecordPtr^).VLongWord := val;
end;
function __TVarData__Wrapper.getVLongWord : LongWord;
begin
result := TVarData(GetRecordPtr^).VLongWord;
end;
procedure ____VariantInit__Wrapper(const p0 : IDispatch);
var
__p0 : ^TVarData;
__i0 : IDispatch;
begin
if p0 = nil then exit;
__p0 := (p0 as IDCRecordWrapper).GetRecordPtr;
VariantInit(__p0^);
end;

function ____VariantClear__Wrapper(const p0 : IDispatch): HRESULT;
var
__p0 : ^TVarData;
__i0 : IDispatch;
begin
if p0 = nil then exit;
__p0 := (p0 as IDCRecordWrapper).GetRecordPtr;
result := VariantClear(__p0^);
end;

function ____VariantCopy__Wrapper(const p0 : IDispatch;
const p1 : IDispatch): HRESULT;
var
__p0 : ^TVarData;
__i0 : IDispatch;
__p1 : ^TVarData;
__i1 : IDispatch;
begin
if p0 = nil then exit;
__p0 := (p0 as IDCRecordWrapper).GetRecordPtr;
if p1 = nil then exit;
__p1 := (p1 as IDCRecordWrapper).GetRecordPtr;
result := VariantCopy(__p0^,__p1^);
end;

function ____VariantCopyInd__Wrapper(const p0 : IDispatch;
const p1 : IDispatch): HRESULT;
var
__p0 : ^TVarData;
__i0 : IDispatch;
__p1 : ^TVarData;
__i1 : IDispatch;
begin
if p0 = nil then exit;
__p0 := (p0 as IDCRecordWrapper).GetRecordPtr;
if p1 = nil then exit;
__p1 := (p1 as IDCRecordWrapper).GetRecordPtr;
result := VariantCopyInd(__p0^,__p1^);
end;

function ____VariantChangeType__Wrapper(const p0 : IDispatch;
const p1 : IDispatch;
p2 : Word;
p3 : Word): HRESULT;
var
__p0 : ^TVarData;
__i0 : IDispatch;
__p1 : ^TVarData;
__i1 : IDispatch;
begin
if p0 = nil then exit;
__p0 := (p0 as IDCRecordWrapper).GetRecordPtr;
if p1 = nil then exit;
__p1 := (p1 as IDCRecordWrapper).GetRecordPtr;
result := VariantChangeType(__p0^,__p1^,p2,p3);
end;


type __TVarData__Wrapper__ = class(__TVarData__Wrapper)
private
fRPtr : pointer;
function GetRecordPtr : pointer; override;
end;
function __TVarData__Wrapper__.GetRecordPtr : pointer;
begin
result := fRPtr;
end;
function ConvertTVarDataToVariant(var R : TVarData) : OleVariant;
var
__rw : __TVarData__Wrapper__;
begin
__rw := __TVarData__Wrapper__.Create;
__rw.fRPtr := @R;
result := IDispatch(__rw);
end;
function ConvertVariantToTVarData(const V : OleVariant) : TVarData;
var
_idisp : IDispatch;
begin
_idisp := VarToInterface(v);
if _idisp = nil then exit;
result := TVarData((_idisp as IDCRecordWrapper).GetRecordPtr^);
end;

type __TVarTypeToElementInfo__Wrapper__ = class(__TVarTypeToElementInfo__Wrapper)
private
fRPtr : pointer;
function GetRecordPtr : pointer; override;
end;
function __TVarTypeToElementInfo__Wrapper__.GetRecordPtr : pointer;
begin
result := fRPtr;
end;
function ConvertTVarTypeToElementInfoToVariant(var R : TVarTypeToElementInfo) : OleVariant;
var
__rw : __TVarTypeToElementInfo__Wrapper__;
begin
__rw := __TVarTypeToElementInfo__Wrapper__.Create;
__rw.fRPtr := @R;
result := IDispatch(__rw);
end;
function ConvertVariantToTVarTypeToElementInfo(const V : OleVariant) : TVarTypeToElementInfo;
var
_idisp : IDispatch;
begin
_idisp := VarToInterface(v);
if _idisp = nil then exit;
result := TVarTypeToElementInfo((_idisp as IDCRecordWrapper).GetRecordPtr^);
end;
function __DC__GetESafeArrayError__ErrorCode(Instance : TObject; Params : PVariantArgList) : OleVariant;
begin
result := ESafeArrayError(Instance).ErrorCode;
end;

procedure __DC__SetESafeArrayError__ErrorCode(Instance : TObject; Params : PVariantArgList);
begin
ESafeArrayError(Instance).ErrorCode:=OleVariant(Params^[0]);
end;

procedure __RegisterProps;
begin
RegisterProperty(ESafeArrayError,'ErrorCode',__DC__GetESafeArrayError__ErrorCode,__DC__SetESafeArrayError__ErrorCode);
end;

const __ConstNames0 : array[0..29] of string = (
'GenericVarUtils'
,'GenericVariants'
,'GenericOperations'
,'GenericSafeArrays'
,'GenericSafeArrayUsesLibC'
,'VAR_OK'
,'VAR_PARAMNOTFOUND'
,'VAR_TYPEMISMATCH'
,'VAR_BADVARTYPE'
,'VAR_EXCEPTION'
,'VAR_OVERFLOW'
,'VAR_BADINDEX'
,'VAR_ARRAYISLOCKED'
,'VAR_NOTIMPL'
,'VAR_OUTOFMEMORY'
,'VAR_INVALIDARG'
,'VAR_UNEXPECTED'
,'ARR_NONE'
,'ARR_FIXEDSIZE'
,'ARR_OLESTR'
,'ARR_UNKNOWN'
,'ARR_DISPATCH'
,'ARR_VARIANT'
,'VAR_CMP_LT'
,'VAR_CMP_EQ'
,'VAR_CMP_GT'
,'VAR_CMP_NULL'
,'VAR_LOCALE_USER_DEFAULT'
,'CMinArrayVarType'
,'CMaxArrayVarType'
);
var __RegisteredConstsList0 : TList;
procedure __RegisterConsts0;
begin
__RegisteredConstsList0 := TList.Create;
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[0] ,GenericVarUtils));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[1] ,GenericVariants));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[2] ,GenericOperations));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[3] ,GenericSafeArrays));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[4] ,GenericSafeArrayUsesLibC));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[5] ,VAR_OK));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[6] ,VAR_PARAMNOTFOUND));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[7] ,VAR_TYPEMISMATCH));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[8] ,VAR_BADVARTYPE));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[9] ,VAR_EXCEPTION));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[10] ,VAR_OVERFLOW));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[11] ,VAR_BADINDEX));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[12] ,VAR_ARRAYISLOCKED));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[13] ,VAR_NOTIMPL));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[14] ,VAR_OUTOFMEMORY));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[15] ,VAR_INVALIDARG));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[16] ,VAR_UNEXPECTED));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[17] ,ARR_NONE));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[18] ,ARR_FIXEDSIZE));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[19] ,ARR_OLESTR));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[20] ,ARR_UNKNOWN));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[21] ,ARR_DISPATCH));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[22] ,ARR_VARIANT));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[23] ,VAR_CMP_LT));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[24] ,VAR_CMP_EQ));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[25] ,VAR_CMP_GT));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[26] ,VAR_CMP_NULL));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[27] ,VAR_LOCALE_USER_DEFAULT));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[28] ,CMinArrayVarType));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[29] ,CMaxArrayVarType));
end;

procedure __UnregisterConsts0;
var i : integer;
begin
__RegisteredConstsList0.Free
end;

const ClassList : array[0..3] of TClass = (
ESafeArrayBoundsError,
ESafeArrayCreateError,
ESafeArrayError,
ESafeArrayLockedError
);
procedure __RegisterClasses;
begin
RegisterClassesInScript(ClassList);
end;

procedure __UnRegisterClasses;
begin
end;

var __RegisteredMethods : TList;
const MethodNames : array[0..8] of string = (
'TVarTypeToElementInfo'
,'VarExceptionToResult'
,'VariantInit'
,'VariantClear'
,'VariantCopy'
,'VariantCopyInd'
,'VariantChangeType'
,'SafeArrayCheck'
,'SafeArrayError'
);

procedure __UnregisterProcs;
var i : integer;
begin
__RegisteredMethods.Free;
end;

procedure _mreg_0;
begin
__RegisteredMethods.Add(RegisterRWProc(MethodNames[0],Addr(_TVarTypeToElementInfo_)));
RegisterProc(nil,MethodNames[1],mtProc,TypeInfo(_T0),[
TypeInfo(Exception),TypeInfo(HRESULT)],Addr(VarExceptionToResult),cRegister);

RegisterProc(nil,MethodNames[2],mtProc,TypeInfo(_T1),[
TypeInfo(IDispatch)],Addr(____VariantInit__Wrapper),cRegister);

RegisterProc(nil,MethodNames[3],mtProc,TypeInfo(_T2),[
TypeInfo(IDispatch),TypeInfo(HRESULT)],Addr(____VariantClear__Wrapper),cRegister);

RegisterProc(nil,MethodNames[4],mtProc,TypeInfo(_T3),[
TypeInfo(IDispatch),
TypeInfo(IDispatch),TypeInfo(HRESULT)],Addr(____VariantCopy__Wrapper),cRegister);

RegisterProc(nil,MethodNames[5],mtProc,TypeInfo(_T4),[
TypeInfo(IDispatch),
TypeInfo(IDispatch),TypeInfo(HRESULT)],Addr(____VariantCopyInd__Wrapper),cRegister);

RegisterProc(nil,MethodNames[6],mtProc,TypeInfo(_T5),[
TypeInfo(IDispatch),
TypeInfo(IDispatch),
TypeInfo(Word),
TypeInfo(Word),TypeInfo(HRESULT)],Addr(____VariantChangeType__Wrapper),cRegister);

RegisterProc(nil,MethodNames[7],mtProc,TypeInfo(_T26),[
TypeInfo(HRESULT)],Addr(SafeArrayCheck),cRegister);

RegisterProc(nil,MethodNames[8],mtProc,TypeInfo(_T27),[
TypeInfo(HRESULT)],Addr(SafeArrayError),cRegister);

RegisterProc(ESafeArrayError,'CreateHResult',mtConstructor,TypeInfo(_T28),[
TypeInfo(HRESULT),
TypeInfo(string)],Addr(ESafeArrayError.CreateHResult),cRegister);

end;
initialization
__RegisteredMethods := TList.Create;
_mreg_0;
{RegisterProc(nil,'SafeArrayCreate',mtProc,TypeInfo(_T6),[
TypeInfo(Integer),
TypeInfo(Integer),
TypeInfo(TVarArrayBoundArray),TypeInfoPointer],Addr(SafeArrayCreate),cStdCall)}

{RegisterProc(nil,'SafeArrayAllocDescriptor',mtProc,TypeInfo(_T7),[
TypeInfo(Integer),
TypeInfoPointer,TypeInfo(HRESULT)],Addr(SafeArrayAllocDescriptor),cStdCall)}

{RegisterProc(nil,'SafeArrayAllocData',mtProc,TypeInfo(_T8),[
TypeInfoPointer,TypeInfo(HRESULT)],Addr(SafeArrayAllocData),cStdCall)}

{RegisterProc(nil,'SafeArrayDestroy',mtProc,TypeInfo(_T9),[
TypeInfoPointer,TypeInfo(HRESULT)],Addr(SafeArrayDestroy),cStdCall)}

{RegisterProc(nil,'SafeArrayDestroyDescriptor',mtProc,TypeInfo(_T10),[
TypeInfoPointer,TypeInfo(HRESULT)],Addr(SafeArrayDestroyDescriptor),cStdCall)}

{RegisterProc(nil,'SafeArrayDestroyData',mtProc,TypeInfo(_T11),[
TypeInfoPointer,TypeInfo(HRESULT)],Addr(SafeArrayDestroyData),cStdCall)}

{RegisterProc(nil,'SafeArrayCopy',mtProc,TypeInfo(_T13),[
TypeInfoPointer,
TypeInfoPointer,TypeInfo(HRESULT)],Addr(SafeArrayCopy),cStdCall)}

{RegisterProc(nil,'SafeArrayCopyData',mtProc,TypeInfo(_T14),[
TypeInfoPointer,
TypeInfoPointer,TypeInfo(HRESULT)],Addr(SafeArrayCopyData),cStdCall)}

{RegisterProc(nil,'SafeArrayGetLBound',mtProc,TypeInfo(_T15),[
TypeInfoPointer,
TypeInfo(Integer),
TypeInfo(Integer),TypeInfo(HRESULT)],Addr(SafeArrayGetLBound),cStdCall)}

{RegisterProc(nil,'SafeArrayGetUBound',mtProc,TypeInfo(_T16),[
TypeInfoPointer,
TypeInfo(Integer),
TypeInfo(Integer),TypeInfo(HRESULT)],Addr(SafeArrayGetUBound),cStdCall)}

{RegisterProc(nil,'SafeArrayGetDim',mtProc,TypeInfo(_T17),[
TypeInfoPointer,TypeInfo(Integer)],Addr(SafeArrayGetDim),cStdCall)}

{RegisterProc(nil,'SafeArrayAccessData',mtProc,TypeInfo(_T18),[
TypeInfoPointer,
TypeInfoPointer,TypeInfo(HRESULT)],Addr(SafeArrayAccessData),cStdCall)}

{RegisterProc(nil,'SafeArrayUnaccessData',mtProc,TypeInfo(_T19),[
TypeInfoPointer,TypeInfo(HRESULT)],Addr(SafeArrayUnaccessData),cStdCall)}

{RegisterProc(nil,'SafeArrayLock',mtProc,TypeInfo(_T20),[
TypeInfoPointer,TypeInfo(HRESULT)],Addr(SafeArrayLock),cStdCall)}

{RegisterProc(nil,'SafeArrayUnlock',mtProc,TypeInfo(_T21),[
TypeInfoPointer,TypeInfo(HRESULT)],Addr(SafeArrayUnlock),cStdCall)}

{RegisterProc(nil,'SafeArrayGetElement',mtProc,TypeInfo(_T22),[
TypeInfoPointer,
TypeInfoPointer,
TypeInfoPointer,TypeInfo(HRESULT)],Addr(SafeArrayGetElement),cStdCall)}

{RegisterProc(nil,'SafeArrayPutElement',mtProc,TypeInfo(_T23),[
TypeInfoPointer,
TypeInfoPointer,
TypeInfoPointer,TypeInfo(HRESULT)],Addr(SafeArrayPutElement),cStdCall)}

{RegisterProc(nil,'SafeArrayPtrOfIndex',mtProc,TypeInfo(_T24),[
TypeInfoPointer,
TypeInfoPointer,
TypeInfoPointer,TypeInfo(HRESULT)],Addr(SafeArrayPtrOfIndex),cStdCall)}

{RegisterProc(nil,'SafeArrayGetElemSize',mtProc,TypeInfo(_T25),[
TypeInfoPointer,TypeInfo(LongWord)],Addr(SafeArrayGetElemSize),cStdCall)}

__RegisterClasses;
__RegisterConsts0;
__RegisterProps;

finalization
__UnRegisterClasses;
__UnregisterConsts0;
__UnregisterProcs;
end.
