{*******************************************************}
{                                                       }
{ Import  unit generated by UNITIMPORTER program         }
{                                                       }
{*******************************************************}

{} unit IDNETWORKCALCULATOR_D2006;
interface
{$I dc.inc}
{$D-,L-,Y-}
{$HINTS OFF}
{$WARNINGS OFF}
uses rtti, 
  activex,
  dcscript,
  dcsystem,
  dcdreamlib,
  SysUtils,
  Classes,
  IdBaseComponent,
  IdNetworkCalculator;
function ConvertTIpStructToVariant(var R : TIpStruct) : OleVariant;
function ConvertVariantToTIpStruct(const V : OleVariant) : TIpStruct;
implementation
  var vmtMethodList:TStringList; 
{$IFDEF D3}
{$ELSE}
uses ole2;
type
  OleVariant = Variant;
{$ENDIF}
type __TIpStruct__Wrapper = class(TDCRecordWrapper)
private
fR : TIpStruct;
public
function GetRecordPtr : pointer; override;
published
procedure setByte4(const val : Byte);
function getByte4 : Byte;
property Byte4 : Byte read getByte4 write setByte4;
procedure setByte3(const val : Byte);
function getByte3 : Byte;
property Byte3 : Byte read getByte3 write setByte3;
procedure setByte2(const val : Byte);
function getByte2 : Byte;
property Byte2 : Byte read getByte2 write setByte2;
procedure setByte1(const val : Byte);
function getByte1 : Byte;
property Byte1 : Byte read getByte1 write setByte1;
procedure setFullAddr(const val : Longword);
function getFullAddr : Longword;
property FullAddr : Longword read getFullAddr write setFullAddr;
end;
type
_T0 = function : Integer of object;

_T1 = function : String of object;

_T2 = _T1;

_T3 = procedure  of object;

_T4 = function (p0 : String): Boolean of object;

_T5 = procedure (p0 : Byte;
p1 : Byte;
p2 : Byte;
p3 : Byte) of object;

function __TIpStruct__Wrapper.GetRecordPtr : pointer;
begin
result := @fR;
end;
procedure __TIpStruct__Wrapper.setByte4(const val : Byte);
begin
TIpStruct(GetRecordPtr^).Byte4 := val;
end;
function __TIpStruct__Wrapper.getByte4 : Byte;
begin
result := TIpStruct(GetRecordPtr^).Byte4;
end;
procedure __TIpStruct__Wrapper.setByte3(const val : Byte);
begin
TIpStruct(GetRecordPtr^).Byte3 := val;
end;
function __TIpStruct__Wrapper.getByte3 : Byte;
begin
result := TIpStruct(GetRecordPtr^).Byte3;
end;
procedure __TIpStruct__Wrapper.setByte2(const val : Byte);
begin
TIpStruct(GetRecordPtr^).Byte2 := val;
end;
function __TIpStruct__Wrapper.getByte2 : Byte;
begin
result := TIpStruct(GetRecordPtr^).Byte2;
end;
procedure __TIpStruct__Wrapper.setByte1(const val : Byte);
begin
TIpStruct(GetRecordPtr^).Byte1 := val;
end;
function __TIpStruct__Wrapper.getByte1 : Byte;
begin
result := TIpStruct(GetRecordPtr^).Byte1;
end;
procedure __TIpStruct__Wrapper.setFullAddr(const val : Longword);
begin
TIpStruct(GetRecordPtr^).FullAddr := val;
end;
function __TIpStruct__Wrapper.getFullAddr : Longword;
begin
result := TIpStruct(GetRecordPtr^).FullAddr;
end;
function _TIpStruct_ : IDispatch;
begin
  result := __TIpStruct__Wrapper.Create;
end;

type __TIpStruct__Wrapper__ = class(__TIpStruct__Wrapper)
private
fRPtr : pointer;
function GetRecordPtr : pointer; override;
end;
function __TIpStruct__Wrapper__.GetRecordPtr : pointer;
begin
result := fRPtr;
end;
function ConvertTIpStructToVariant(var R : TIpStruct) : OleVariant;
var
__rw : __TIpStruct__Wrapper__;
begin
__rw := __TIpStruct__Wrapper__.Create;
__rw.fRPtr := @R;
result := IDispatch(__rw);
end;
function ConvertVariantToTIpStruct(const V : OleVariant) : TIpStruct;
var
_idisp : IDispatch;
begin
_idisp := VarToInterface(v);
if _idisp = nil then exit;
result := TIpStruct((_idisp as IDCRecordWrapper).GetRecordPtr^);
end;
function __DC__GetTIdNetworkCalculator__ListIP(Instance : TObject; Params : PVariantArgList) : OleVariant;
begin
result := VarFromObject(TIdNetworkCalculator(Instance).ListIP);
end;

function __DC__GetTIdNetworkCalculator__NetworkClass(Instance : TObject; Params : PVariantArgList) : OleVariant;
begin
result := TIdNetworkCalculator(Instance).NetworkClass;
end;

function __DC__GetTIdNetworkCalculator__NetworkClassAsString(Instance : TObject; Params : PVariantArgList) : OleVariant;
begin
result := TIdNetworkCalculator(Instance).NetworkClassAsString;
end;

function __DC__GetTIdNetworkCalculator__IsAddressRoutable(Instance : TObject; Params : PVariantArgList) : OleVariant;
begin
result := TIdNetworkCalculator(Instance).IsAddressRoutable;
end;

function __DC__GetTIpProperty__ByteArray(Instance : TObject; Params : PVariantArgList) : OleVariant;
begin
result := TIpProperty(Instance).ByteArray[OleVariant(Params^[0])];
end;

procedure __DC__SetTIpProperty__ByteArray(Instance : TObject; Params : PVariantArgList);
begin
TIpProperty(Instance).ByteArray[OleVariant(Params^[1])]:=OleVariant(Params^[0]);
end;

function __DC__GetTIpProperty__AddressType(Instance : TObject; Params : PVariantArgList) : OleVariant;
begin
result := TIpProperty(Instance).AddressType;
end;

procedure __RegisterProps;
begin
RegisterProperty(TIdNetworkCalculator,'ListIP',__DC__GetTIdNetworkCalculator__ListIP,nil);
RegisterProperty(TIdNetworkCalculator,'NetworkClass',__DC__GetTIdNetworkCalculator__NetworkClass,nil);
RegisterProperty(TIdNetworkCalculator,'NetworkClassAsString',__DC__GetTIdNetworkCalculator__NetworkClassAsString,nil);
RegisterProperty(TIdNetworkCalculator,'IsAddressRoutable',__DC__GetTIdNetworkCalculator__IsAddressRoutable,nil);
RegisterIndexedProperty(TIpProperty,'ByteArray',1,False,__DC__GetTIpProperty__ByteArray,__DC__SetTIpProperty__ByteArray);
RegisterProperty(TIpProperty,'AddressType',__DC__GetTIpProperty__AddressType,nil);
end;

const __ConstNames0 : array[0..14] of string = (
'ID_NET_CLASS_A'
,'ID_NET_CLASS_B'
,'ID_NET_CLASS_C'
,'ID_NET_CLASS_D'
,'ID_NET_CLASS_E'
,'ID_NC_MASK_LENGTH'
,'IPLocalHost'
,'IPLocalNetwork'
,'IPReserved'
,'IPInternetHost'
,'IPPrivateNetwork'
,'IPLoopback'
,'IPMulticast'
,'IPFutureUse'
,'IPGlobalBroadcast'
);
var __RegisteredConstsList0 : TList;
procedure __RegisterConsts0;
begin
__RegisteredConstsList0 := TList.Create;
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[0] ,ID_NET_CLASS_A));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[1] ,ID_NET_CLASS_B));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[2] ,ID_NET_CLASS_C));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[3] ,ID_NET_CLASS_D));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[4] ,ID_NET_CLASS_E));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[5] ,ID_NC_MASK_LENGTH));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[6] ,IPLocalHost));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[7] ,IPLocalNetwork));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[8] ,IPReserved));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[9] ,IPInternetHost));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[10] ,IPPrivateNetwork));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[11] ,IPLoopback));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[12] ,IPMulticast));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[13] ,IPFutureUse));
__RegisteredConstsList0.Add(RegisterConst(__ConstNames0[14] ,IPGlobalBroadcast));
end;

procedure __UnregisterConsts0;
var i : integer;
begin
__RegisteredConstsList0.Free
end;

const ClassList : array[0..1] of TClass = (
TIdNetworkCalculator,
TIpProperty
);
 function __getFullMethodName(sclassName, smethodName:String):String; 
 begin 
   result := format('%s.%s',[sClassName, sMethodName]) 
 end; 
procedure fillVMTProcs();
var
  ctx : TRttiContext;
  t:TRttiType;
  m:TRttiMethod;
  i:Integer;
begin
  ctx := TRttiContext.Create;
  try
    for i := 0 to length(classList) - 1 do
    begin
      t:=ctx.GetType(classList[i].ClassInfo);
      for m in t.GetMethods  do
      begin
        if m.DispatchKind = dkVtable then
        vmtMethodList.addObject(__getFullMethodName(classList[i].className,m.Name), pointer(m.VirtualIndex*4));
      end;
      t.free;
    end;
  finally
    ctx.free;
  end;
end;
function getVMTProcAddr(className, MethodName:String;oldAddr:Integer):Pointer;
var i:Integer;
begin
  i:=vmtMethodList.indexOf(__getFullMethodName(className,methodName));
  if i>-1 then 
    result:=pointer(vmtMethodList.Objects[i])
  else 
  result:=pointer(oldAddr);
end;  
procedure __RegisterClasses;
begin
RegisterClassesInScript(ClassList);
end;

procedure __UnRegisterClasses;
begin
end;

var __RegisteredMethods : TList;
const MethodNames : array[0..0] of string = (
'TIpStruct'
);

procedure __UnregisterProcs;
var i : integer;
begin
__RegisteredMethods.Free;
end;

procedure _mreg_0;
begin
__RegisteredMethods.Add(RegisterRWProc(MethodNames[0],Addr(_TIpStruct_)));
RegRegisterMethod(TIdNetworkCalculator,'NumIP',TypeInfo(_T0),[TypeInfo(Integer)],Addr(TIdNetworkCalculator.NumIP));

RegRegisterMethod(TIdNetworkCalculator,'StartIP',TypeInfo(_T1),[TypeInfo(String)],Addr(TIdNetworkCalculator.StartIP));

RegRegisterMethod(TIdNetworkCalculator,'EndIP',TypeInfo(_T2),[TypeInfo(String)],Addr(TIdNetworkCalculator.EndIP));

RegRegisterMethod(TIdNetworkCalculator,'FillIPList',TypeInfo(_T3),NoParams,Addr(TIdNetworkCalculator.FillIPList));

RegRegisterMethod(TIdNetworkCalculator,'IsAddressInNetwork',TypeInfo(_T4),[
TypeInfo(String),TypeInfo(Boolean)],Addr(TIdNetworkCalculator.IsAddressInNetwork));

//RegRegisterMethod(TIpProperty,'SetAll',TypeInfo(_T5),[TypeInfo(Byte),TypeInfo(Byte),TypeInfo(Byte),TypeInfo(Byte)], pointer(12));
RegRegisterMethod(TIpProperty,'SetAll',TypeInfo(_T5),[TypeInfo(Byte),TypeInfo(Byte),TypeInfo(Byte),TypeInfo(Byte)],  getVMTProcAddr('TIpProperty','SetAll',12));


end;
initialization
 vmtMethodList:=TStringList.Create;
vmtMethodList.sorted:=true;
vmtMethodList.duplicates:=dupIgnore;
fillVMTProcs;
__RegisteredMethods := TList.Create;
_mreg_0;
__RegisterClasses;
__RegisterConsts0;
__RegisterProps;
vmtMethodList.free

finalization
__UnRegisterClasses;
__UnregisterConsts0;
__UnregisterProcs;
end.
